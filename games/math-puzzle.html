<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#e94560">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
    <title>Math Crossword - Mini Games Arcade</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e0e5ec 0%, #d0d5dc 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: max(20px, env(safe-area-inset-top)) 20px 20px;
        }

        .header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .back-btn {
            color: #2e7d32;
            text-decoration: none;
            font-size: 1.5rem;
            padding: 8px 12px;
            border-radius: 10px;
            transition: background 0.2s;
        }

        .back-btn:hover { background: rgba(46, 125, 50, 0.2); }

        h1 {
            color: #1b5e20;
            font-size: 1.6rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .subtitle {
            color: #558b2f;
            font-size: 0.95rem;
            text-align: center;
            margin-bottom: 15px;
        }

        .stats-bar {
            display: flex;
            gap: 12px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stat {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.95rem;
            font-weight: bold;
        }

        .stat.level {
            background: linear-gradient(145deg, #7c4dff, #651fff);
            color: white;
        }

        .stat.score {
            background: white;
            color: #333;
            border: 2px solid #ddd;
        }

        .stat.timer {
            background: linear-gradient(145deg, #ff6b6b, #ee5a5a);
            color: white;
        }

        .puzzle-container {
            background: linear-gradient(145deg, #d0d5dc, #e8edf4);
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            margin-bottom: 20px;
        }

        .puzzle-grid {
            display: grid;
            gap: 2px;
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 50%;
        }

        .cell.number {
            background: white;
            border: 3px solid #b0b8c0;
            color: #333;
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.1);
        }

        .cell.input {
            background: linear-gradient(145deg, #e8f5f0, #d0ebe5);
            border: 3px solid #80cbc4;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cell.input:hover { border-color: #26a69a; transform: scale(1.05); }
        .cell.input.selected { border-color: #00897b; background: #b2dfdb; box-shadow: 0 0 10px rgba(0,150,136,0.5); }
        .cell.input.correct { border-color: #4caf50; background: #c8e6c9; }
        .cell.input.wrong { border-color: #f44336; background: #ffcdd2; animation: shake 0.3s; }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .cell.operator {
            color: #444;
            background: transparent;
            font-weight: bold;
        }

        .cell.equals {
            color: #444;
            background: transparent;
            font-weight: bold;
        }

        .cell.empty {
            background: transparent;
        }

        .numpad {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 20px;
            max-width: 350px;
        }

        .num-btn {
            width: 56px;
            height: 56px;
            border: none;
            border-radius: 12px;
            font-size: 1.4rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(145deg, #81c784, #66bb6a);
            color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .num-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2); }
        .num-btn:active { transform: translateY(0); }

        .num-btn.clear {
            background: linear-gradient(145deg, #ef5350, #e53935);
        }

        .buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 14px 28px;
            font-size: 1rem;
            font-weight: bold;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover { transform: translateY(-2px); }

        .btn.check {
            background: linear-gradient(145deg, #66bb6a, #4caf50);
            color: white;
        }

        .btn.next {
            background: linear-gradient(145deg, #ffd54f, #ffca28);
            color: #5d4037;
        }

        .btn.quit {
            background: rgba(0, 0, 0, 0.1);
            color: #666;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal.show { display: flex; }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 350px;
            width: 90%;
        }

        .modal-content h2 {
            color: #2e7d32;
            margin-bottom: 15px;
        }

        .modal-content .emoji { font-size: 3rem; margin-bottom: 10px; }

        .modal-content p { color: #666; margin-bottom: 10px; }

        .final-stats {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
        }

        .final-stats p { margin: 5px 0; color: #333; }

        .name-input {
            margin: 15px 0;
        }

        .name-input input {
            padding: 12px;
            font-size: 1rem;
            border: 2px solid #81c784;
            border-radius: 10px;
            width: 180px;
            text-align: center;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Setup screen */
        .setup-screen {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .setup-screen h2 {
            color: #2e7d32;
            margin-bottom: 20px;
        }

        .difficulty-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .diff-btn {
            padding: 15px;
            border: 3px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            background: #f5f5f5;
        }

        .diff-btn:hover { background: #e8f5e9; }
        .diff-btn.selected { border-color: #4caf50; background: #e8f5e9; }

        .diff-btn .title { font-weight: bold; color: #2e7d32; }
        .diff-btn .desc { font-size: 0.85rem; color: #666; margin-top: 5px; }

        .screen { display: none; }
        .screen.active { display: block; }

        @media (max-width: 400px) {
            .puzzle-container { padding: 10px; }
            .num-btn { width: 48px; height: 48px; font-size: 1.2rem; }
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="../index.html" class="back-btn">‚Üê</a>
        <h1>Math Crossword</h1>
    </div>

    <!-- Setup Screen -->
    <div class="screen setup-screen active" id="setupScreen">
        <h2>üßÆ Math Crossword</h2>
        <p style="color:#666;margin-bottom:20px;">Fill in the blanks so all equations work horizontally and vertically!</p>

        <div class="difficulty-options">
            <div class="diff-btn selected" data-diff="easy">
                <div class="title">Easy</div>
                <div class="desc">3√ó3 grid, + and - only</div>
            </div>
            <div class="diff-btn" data-diff="medium">
                <div class="title">Medium</div>
                <div class="desc">4√ó4 grid, + - √ó operations</div>
            </div>
            <div class="diff-btn" data-diff="hard">
                <div class="title">Hard</div>
                <div class="desc">5√ó5 grid, all operations, more blanks</div>
            </div>
        </div>

        <div class="buttons">
            <button class="btn check" id="startBtn">Start Game</button>
            <button class="btn quit" id="viewScoresBtn">Leaderboard</button>
        </div>
    </div>

    <!-- Game Screen -->
    <div class="screen" id="gameScreen">
        <p class="subtitle" id="subtitleText">Fill numbers so equations work!</p>

        <div class="stats-bar">
            <div class="stat level">Level: <span id="level">1</span>/10</div>
            <div class="stat score">Score: <span id="score">0</span></div>
            <div class="stat timer">Time: <span id="timer">0</span>s</div>
        </div>

        <div class="puzzle-container">
            <div class="puzzle-grid" id="puzzleGrid"></div>
        </div>

        <div class="numpad" id="numpad"></div>

        <div class="buttons">
            <button class="btn check" id="checkBtn">Check Answer</button>
            <button class="btn next" id="nextBtn" style="display:none;">Next Level</button>
            <button class="btn quit" id="quitBtn">Quit</button>
        </div>
    </div>

    <!-- Result Modal -->
    <div class="modal" id="resultModal">
        <div class="modal-content">
            <div class="emoji" id="resultEmoji">üéâ</div>
            <h2 id="resultTitle">Game Complete!</h2>
            <p id="resultMessage">Great job!</p>

            <div class="final-stats">
                <p>Final Score: <strong id="finalScore">0</strong></p>
                <p>Levels Completed: <strong id="levelsCompleted">0</strong></p>
                <p>Total Time: <strong id="totalTime">0</strong>s</p>
            </div>

            <div class="name-input" id="nameInput">
                <p style="color:#4caf50;margin-bottom:10px;">Enter your name:</p>
                <input type="text" id="playerName" placeholder="Your name" maxlength="15">
            </div>

            <div class="modal-buttons">
                <button class="btn check" id="playAgainBtn">Play Again</button>
                <button class="btn quit" id="menuBtn">Menu</button>
            </div>
        </div>
    </div>

    <!-- Scoreboard Modal -->
    <div class="modal" id="scoreboardModal">
        <div class="modal-content">
            <h2>üèÜ Leaderboard</h2>
            <div id="scoreboardList" style="margin:15px 0;"></div>
            <div class="modal-buttons">
                <button class="btn quit" id="closeScoresBtn">Close</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script src="../js/supabase-config.js"></script>
    <script src="../js/ad-manager.js"></script>
    <script>document.addEventListener('DOMContentLoaded', () => AdManager.init());</script>
    <script>
        let state = {
            difficulty: 'easy',
            level: 1,
            score: 0,
            time: 0,
            totalTime: 0,
            puzzle: null,
            selectedCell: null,
            timerInterval: null,
            gridSize: 3,
            blanksCount: 3
        };

        const DIFFICULTY = {
            easy: { gridSize: 3, blanks: 3, ops: ['+', '-'], maxNum: 15 },
            medium: { gridSize: 4, blanks: 5, ops: ['+', '-', '√ó'], maxNum: 20 },
            hard: { gridSize: 5, blanks: 7, ops: ['+', '-', '√ó'], maxNum: 30 }
        };

        function randInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function shuffle(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function applyOp(a, op, b) {
            if (op === '+') return a + b;
            if (op === '-') return a - b;
            if (op === '√ó') return a * b;
            return 0;
        }

        function generatePuzzle() {
            const config = DIFFICULTY[state.difficulty];
            const { gridSize, blanks, ops, maxNum } = config;
            state.gridSize = gridSize;
            state.blanksCount = blanks;

            let puzzle = null;
            let attempts = 0;

            while (attempts < 500 && !puzzle) {
                attempts++;
                puzzle = tryGeneratePuzzle(gridSize, ops, maxNum);
            }

            if (!puzzle) {
                // Fallback simple puzzle
                puzzle = createFallbackPuzzle(gridSize);
            }

            // Select blanks
            const allPositions = [];
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    allPositions.push({ r, c });
                }
            }
            shuffle(allPositions);
            puzzle.blanks = allPositions.slice(0, blanks).map(p => `${p.r},${p.c}`);
            puzzle.userInputs = {};

            return puzzle;
        }

        function tryGeneratePuzzle(size, availableOps, maxNum) {
            // Generate a valid grid where:
            // - Each row forms an equation: a op b op c ... = result
            // - Each column forms an equation: a op b op c ... = result

            const grid = [];
            const rowOps = [];
            const colOps = [];

            // For simplicity, we'll generate values that work for both directions
            // Strategy: Generate random values, then calculate results

            // Initialize grid with random small numbers
            for (let r = 0; r < size; r++) {
                grid[r] = [];
                for (let c = 0; c < size; c++) {
                    if (availableOps.includes('√ó')) {
                        grid[r][c] = randInt(1, Math.min(9, maxNum));
                    } else {
                        grid[r][c] = randInt(1, Math.min(15, maxNum));
                    }
                }
            }

            // Generate operators for rows
            for (let r = 0; r < size; r++) {
                rowOps[r] = [];
                for (let c = 0; c < size - 1; c++) {
                    rowOps[r][c] = availableOps[randInt(0, availableOps.length - 1)];
                }
            }

            // Generate operators for columns
            for (let c = 0; c < size; c++) {
                colOps[c] = [];
                for (let r = 0; r < size - 1; r++) {
                    colOps[c][r] = availableOps[randInt(0, availableOps.length - 1)];
                }
            }

            // Calculate row results
            const rowResults = [];
            for (let r = 0; r < size; r++) {
                let result = grid[r][0];
                for (let c = 1; c < size; c++) {
                    result = applyOp(result, rowOps[r][c-1], grid[r][c]);
                }
                rowResults[r] = result;
            }

            // Calculate column results
            const colResults = [];
            for (let c = 0; c < size; c++) {
                let result = grid[0][c];
                for (let r = 1; r < size; r++) {
                    result = applyOp(result, colOps[c][r-1], grid[r][c]);
                }
                colResults[c] = result;
            }

            // Validate all results are positive integers within range
            for (let i = 0; i < size; i++) {
                if (rowResults[i] < 0 || rowResults[i] > maxNum * 3 || !Number.isInteger(rowResults[i])) {
                    return null;
                }
                if (colResults[i] < 0 || colResults[i] > maxNum * 3 || !Number.isInteger(colResults[i])) {
                    return null;
                }
            }

            // Also validate all grid values
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (grid[r][c] < 0 || grid[r][c] > maxNum) {
                        return null;
                    }
                }
            }

            return {
                grid,
                rowOps,
                colOps,
                rowResults,
                colResults,
                size
            };
        }

        function createFallbackPuzzle(size) {
            // Create a simple addition-only puzzle
            const grid = [];
            const rowOps = [];
            const colOps = [];
            const rowResults = [];
            const colResults = [];

            for (let r = 0; r < size; r++) {
                grid[r] = [];
                rowOps[r] = [];
                for (let c = 0; c < size; c++) {
                    grid[r][c] = r + c + 1;
                    if (c < size - 1) rowOps[r][c] = '+';
                }
            }

            for (let c = 0; c < size; c++) {
                colOps[c] = [];
                for (let r = 0; r < size - 1; r++) {
                    colOps[c][r] = '+';
                }
            }

            // Calculate results
            for (let r = 0; r < size; r++) {
                let result = grid[r][0];
                for (let c = 1; c < size; c++) {
                    result = applyOp(result, rowOps[r][c-1], grid[r][c]);
                }
                rowResults[r] = result;
            }

            for (let c = 0; c < size; c++) {
                let result = grid[0][c];
                for (let r = 1; r < size; r++) {
                    result = applyOp(result, colOps[c][r-1], grid[r][c]);
                }
                colResults[c] = result;
            }

            return { grid, rowOps, colOps, rowResults, colResults, size };
        }

        function renderPuzzle() {
            const gridEl = document.getElementById('puzzleGrid');
            const puzzle = state.puzzle;
            const size = puzzle.size;

            // Grid has: size number columns + (size-1) operator columns + 1 equals column + 1 result column
            // = size + (size-1) + 1 + 1 = 2*size + 1
            const cols = size * 2 + 1;
            const rows = size * 2 + 1;

            // Calculate cell size based on grid size
            const baseCellSize = state.difficulty === 'easy' ? 50 : (state.difficulty === 'medium' ? 42 : 36);
            const cellSize = baseCellSize;
            const opSize = Math.floor(cellSize * 0.6);

            gridEl.style.gridTemplateColumns = generateGridTemplate(size, cellSize, opSize);
            gridEl.style.gridTemplateRows = generateGridTemplate(size, cellSize, opSize);
            gridEl.innerHTML = '';

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const div = document.createElement('div');

                    const isNumberRow = row % 2 === 0;
                    const isNumberCol = col % 2 === 0;
                    const gridRow = Math.floor(row / 2);
                    const gridCol = Math.floor(col / 2);

                    if (isNumberRow && isNumberCol) {
                        // Number cell
                        if (gridCol < size && gridRow < size) {
                            // Main grid number
                            const key = `${gridRow},${gridCol}`;
                            const isBlank = puzzle.blanks.includes(key);
                            const value = puzzle.grid[gridRow][gridCol];

                            if (isBlank) {
                                div.className = 'cell input';
                                div.dataset.key = key;
                                div.textContent = puzzle.userInputs[key] || '';
                                div.style.width = cellSize + 'px';
                                div.style.height = cellSize + 'px';
                                div.style.fontSize = (cellSize * 0.45) + 'px';
                                div.addEventListener('click', () => selectCell(div, key));
                            } else {
                                div.className = 'cell number';
                                div.textContent = value;
                                div.style.width = cellSize + 'px';
                                div.style.height = cellSize + 'px';
                                div.style.fontSize = (cellSize * 0.45) + 'px';
                            }
                        } else if (gridCol === size && gridRow < size) {
                            // Row result
                            div.className = 'cell number';
                            div.textContent = puzzle.rowResults[gridRow];
                            div.style.width = cellSize + 'px';
                            div.style.height = cellSize + 'px';
                            div.style.fontSize = (cellSize * 0.45) + 'px';
                        } else if (gridRow === size && gridCol < size) {
                            // Column result
                            div.className = 'cell number';
                            div.textContent = puzzle.colResults[gridCol];
                            div.style.width = cellSize + 'px';
                            div.style.height = cellSize + 'px';
                            div.style.fontSize = (cellSize * 0.45) + 'px';
                        } else {
                            div.className = 'cell empty';
                        }
                    } else if (isNumberRow && !isNumberCol) {
                        // Horizontal operator (between columns in same row)
                        const opCol = Math.floor((col - 1) / 2);
                        if (opCol < size - 1 && gridRow < size) {
                            div.className = 'cell operator';
                            div.textContent = puzzle.rowOps[gridRow][opCol];
                            div.style.fontSize = (opSize * 0.6) + 'px';
                        } else if (opCol === size - 1 && gridRow < size) {
                            // Equals sign before result
                            div.className = 'cell equals';
                            div.textContent = '=';
                            div.style.fontSize = (opSize * 0.6) + 'px';
                        } else {
                            div.className = 'cell empty';
                        }
                    } else if (!isNumberRow && isNumberCol) {
                        // Vertical operator (between rows in same column)
                        const opRow = Math.floor((row - 1) / 2);
                        if (opRow < size - 1 && gridCol < size) {
                            div.className = 'cell operator';
                            div.textContent = puzzle.colOps[gridCol][opRow];
                            div.style.fontSize = (opSize * 0.6) + 'px';
                        } else if (opRow === size - 1 && gridCol < size) {
                            // Equals sign before result
                            div.className = 'cell equals';
                            div.textContent = '=';
                            div.style.fontSize = (opSize * 0.6) + 'px';
                        } else {
                            div.className = 'cell empty';
                        }
                    } else {
                        // Corner/intersection (empty)
                        div.className = 'cell empty';
                    }

                    gridEl.appendChild(div);
                }
            }

            // Update subtitle
            const hasMultiply = state.difficulty !== 'easy';
            document.getElementById('subtitleText').textContent =
                hasMultiply ? 'Fill blanks: + - √ó work in rows & columns!' : 'Fill blanks: + - work in rows & columns!';
        }

        function generateGridTemplate(size, cellSize, opSize) {
            const parts = [];
            for (let i = 0; i < size; i++) {
                parts.push(cellSize + 'px');
                if (i < size - 1) {
                    parts.push(opSize + 'px');
                }
            }
            // Add equals column and result column
            parts.push(opSize + 'px');
            parts.push(cellSize + 'px');
            return parts.join(' ');
        }

        function renderNumpad() {
            const numpad = document.getElementById('numpad');
            numpad.innerHTML = '';

            // Determine max number needed
            const puzzle = state.puzzle;
            let maxNeeded = 0;
            for (let r = 0; r < puzzle.size; r++) {
                for (let c = 0; c < puzzle.size; c++) {
                    maxNeeded = Math.max(maxNeeded, puzzle.grid[r][c]);
                }
            }

            const showMax = Math.min(Math.max(maxNeeded + 3, 10), 20);

            // First row: 1-5
            for (let i = 1; i <= 5; i++) {
                addNumButton(numpad, i);
            }

            // Second row: 6-10 or 6-9 + clear
            for (let i = 6; i <= 10; i++) {
                addNumButton(numpad, i);
            }

            // Additional rows if needed
            if (showMax > 10) {
                for (let i = 11; i <= Math.min(showMax, 15); i++) {
                    addNumButton(numpad, i);
                }
            }

            if (showMax > 15) {
                for (let i = 16; i <= Math.min(showMax, 20); i++) {
                    addNumButton(numpad, i);
                }
            }

            // Clear button
            const clearBtn = document.createElement('button');
            clearBtn.className = 'num-btn clear';
            clearBtn.textContent = '‚úï';
            clearBtn.addEventListener('click', () => inputNumber(null));
            numpad.appendChild(clearBtn);
        }

        function addNumButton(container, num) {
            const btn = document.createElement('button');
            btn.className = 'num-btn';
            btn.textContent = num;
            btn.addEventListener('click', () => inputNumber(num));
            container.appendChild(btn);
        }

        function selectCell(div, key) {
            document.querySelectorAll('.cell.input').forEach(c => c.classList.remove('selected'));
            div.classList.add('selected');
            state.selectedCell = key;
        }

        function inputNumber(num) {
            if (state.selectedCell === null) return;

            const puzzle = state.puzzle;
            if (num === null) {
                delete puzzle.userInputs[state.selectedCell];
            } else {
                puzzle.userInputs[state.selectedCell] = num;
            }

            renderPuzzle();

            // Re-select the cell
            const cell = document.querySelector(`.cell.input[data-key="${state.selectedCell}"]`);
            if (cell) cell.classList.add('selected');
        }

        function checkAnswer() {
            const puzzle = state.puzzle;

            // Check if all blanks are filled
            for (const key of puzzle.blanks) {
                if (puzzle.userInputs[key] === undefined) {
                    alert('Please fill in all blank cells!');
                    return false;
                }
            }

            // Get current grid values
            const currentGrid = [];
            for (let r = 0; r < puzzle.size; r++) {
                currentGrid[r] = [];
                for (let c = 0; c < puzzle.size; c++) {
                    const key = `${r},${c}`;
                    if (puzzle.blanks.includes(key)) {
                        currentGrid[r][c] = puzzle.userInputs[key];
                    } else {
                        currentGrid[r][c] = puzzle.grid[r][c];
                    }
                }
            }

            // Check all row equations
            let allCorrect = true;
            for (let r = 0; r < puzzle.size; r++) {
                let result = currentGrid[r][0];
                for (let c = 1; c < puzzle.size; c++) {
                    result = applyOp(result, puzzle.rowOps[r][c-1], currentGrid[r][c]);
                }
                if (result !== puzzle.rowResults[r]) {
                    allCorrect = false;
                }
            }

            // Check all column equations
            for (let c = 0; c < puzzle.size; c++) {
                let result = currentGrid[0][c];
                for (let r = 1; r < puzzle.size; r++) {
                    result = applyOp(result, puzzle.colOps[c][r-1], currentGrid[r][c]);
                }
                if (result !== puzzle.colResults[c]) {
                    allCorrect = false;
                }
            }

            // Show feedback on cells
            document.querySelectorAll('.cell.input').forEach(cell => {
                const key = cell.dataset.key;
                const [r, c] = key.split(',').map(Number);
                const correct = puzzle.userInputs[key] === puzzle.grid[r][c];
                cell.classList.remove('correct', 'wrong');
                cell.classList.add(correct ? 'correct' : 'wrong');
            });

            if (allCorrect) {
                const timeBonus = Math.max(0, 150 - state.time);
                const levelBonus = state.level * 50;
                const diffBonus = state.difficulty === 'hard' ? 150 : (state.difficulty === 'medium' ? 75 : 0);
                const sizeBonus = puzzle.size * 20;
                state.score += timeBonus + levelBonus + 100 + diffBonus + sizeBonus;
                state.totalTime += state.time;

                document.getElementById('score').textContent = state.score;
                document.getElementById('checkBtn').style.display = 'none';
                document.getElementById('nextBtn').style.display = 'inline-block';

                clearInterval(state.timerInterval);
            }

            return allCorrect;
        }

        function nextLevel() {
            state.level++;

            if (state.level > 10) {
                endGame(true);
                return;
            }

            state.time = 0;
            state.selectedCell = null;
            state.puzzle = generatePuzzle();

            document.getElementById('level').textContent = state.level;
            document.getElementById('timer').textContent = '0';
            document.getElementById('checkBtn').style.display = 'inline-block';
            document.getElementById('nextBtn').style.display = 'none';

            renderPuzzle();
            renderNumpad();
            startTimer();
        }

        function startTimer() {
            clearInterval(state.timerInterval);
            state.timerInterval = setInterval(() => {
                state.time++;
                document.getElementById('timer').textContent = state.time;
            }, 1000);
        }

        function startGame() {
            state.level = 1;
            state.score = 0;
            state.time = 0;
            state.totalTime = 0;
            state.selectedCell = null;
            state.puzzle = generatePuzzle();

            document.getElementById('setupScreen').classList.remove('active');
            document.getElementById('gameScreen').classList.add('active');

            document.getElementById('level').textContent = '1';
            document.getElementById('score').textContent = '0';
            document.getElementById('timer').textContent = '0';
            document.getElementById('checkBtn').style.display = 'inline-block';
            document.getElementById('nextBtn').style.display = 'none';

            renderPuzzle();
            renderNumpad();
            startTimer();
        }

        function endGame(completed) {
            clearInterval(state.timerInterval);

            const modal = document.getElementById('resultModal');
            document.getElementById('finalScore').textContent = state.score;
            document.getElementById('levelsCompleted').textContent = state.level - 1;
            document.getElementById('totalTime').textContent = state.totalTime;

            if (completed) {
                document.getElementById('resultEmoji').textContent = 'üèÜ';
                document.getElementById('resultTitle').textContent = 'Congratulations!';
                document.getElementById('resultMessage').textContent = 'You completed all 10 levels!';
                state.score += 500;
            } else {
                document.getElementById('resultEmoji').textContent = 'üëç';
                document.getElementById('resultTitle').textContent = 'Game Over';
                document.getElementById('resultMessage').textContent = 'Great effort!';
            }

            AdManager.showInterstitial(() => {
                setTimeout(() => modal.classList.add('show'), 300);
            });
        }

        // Event listeners
        document.querySelectorAll('.diff-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                state.difficulty = btn.dataset.diff;
            });
        });

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('checkBtn').addEventListener('click', checkAnswer);
        document.getElementById('nextBtn').addEventListener('click', nextLevel);

        document.getElementById('quitBtn').addEventListener('click', () => {
            clearInterval(state.timerInterval);
            endGame(false);
        });

        document.getElementById('playAgainBtn').addEventListener('click', async () => {
            await saveScore();
            document.getElementById('resultModal').classList.remove('show');
            document.getElementById('gameScreen').classList.remove('active');
            document.getElementById('setupScreen').classList.add('active');
        });

        document.getElementById('menuBtn').addEventListener('click', async () => {
            await saveScore();
            window.location.href = '../index.html';
        });

        document.getElementById('viewScoresBtn').addEventListener('click', showScoreboard);
        document.getElementById('closeScoresBtn').addEventListener('click', () => {
            document.getElementById('scoreboardModal').classList.remove('show');
        });

        async function saveScore() {
            if (state.score > 0 && typeof addScoreToDB === 'function') {
                const name = document.getElementById('playerName').value.trim() || 'Anonymous';
                await addScoreToDB('math_puzzle', name, state.score, state.difficulty);
                document.getElementById('playerName').value = '';
            }
        }

        async function showScoreboard() {
            const container = document.getElementById('scoreboardList');
            container.innerHTML = '<p style="color:#888;padding:20px;">Loading...</p>';
            document.getElementById('scoreboardModal').classList.add('show');

            if (typeof getScoresFromDB !== 'function') {
                container.innerHTML = '<p style="color:#888;padding:20px;">Scoreboard unavailable</p>';
                return;
            }

            const scores = await getScoresFromDB('math_puzzle');
            if (scores.length === 0) {
                container.innerHTML = '<p style="color:#888;padding:20px;">No scores yet!</p>';
                return;
            }

            let html = '<div style="text-align:left;">';
            scores.forEach((entry, i) => {
                html += `<div style="display:flex;justify-content:space-between;padding:8px 10px;background:#f5f5f5;margin:3px 0;border-radius:5px;">
                    <span style="color:#4caf50;font-weight:bold;width:25px;">#${i+1}</span>
                    <span style="flex:1;color:#333;">${entry.player_name}</span>
                    <span style="color:#2e7d32;font-weight:bold;">${entry.score.toLocaleString()}</span>
                </div>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }
    </script>
</body>
</html>
